Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Storage = undefined;

var _reactNative = require('react-native');

var _promisify = require('../utils/promisify');

var _promisify2 = babelHelpers.interopRequireDefault(_promisify);

var _base = require('./base');

var FirestackStorage = _reactNative.NativeModules.FirestackStorage;
var FirestackStorageEvt = new _reactNative.NativeEventEmitter(FirestackStorage);

console.log('FirestackStorage ---->', FirestackStorage);

var StorageRef = function (_ReferenceBase) {
  babelHelpers.inherits(StorageRef, _ReferenceBase);

  function StorageRef(storage, path) {
    babelHelpers.classCallCheck(this, StorageRef);

    var _this = babelHelpers.possibleConstructorReturn(this, (StorageRef.__proto__ || Object.getPrototypeOf(StorageRef)).call(this, storage.firestack, path));

    _this.storage = storage;
    return _this;
  }

  babelHelpers.createClass(StorageRef, [{
    key: 'downloadUrl',
    value: function downloadUrl() {
      var path = this.pathToString();
      return (0, _promisify2.default)('downloadUrl', FirestackStorage)(this.storage.storageUrl, path);
    }
  }, {
    key: 'download',
    value: function download(downloadPath, cb) {
      var _this2 = this;

      var callback = cb;
      if (!callback || typeof callback !== 'function') {
        callback = function callback(evt) {};
      }

      var listeners = [];
      listeners.push(this.storage._addListener('download_progress', callback));
      listeners.push(this.storage._addListener('download_paused', callback));
      listeners.push(this.storage._addListener('download_resumed', callback));

      var path = this.pathToString();
      return (0, _promisify2.default)('downloadFile', FirestackStorage)(this.storage.storageUrl, path, downloadPath).then(function (res) {
        console.log('res --->', res);
        listeners.forEach(_this2.storage._removeListener);
        return res;
      }).catch(function (err) {
        console.log('Got an error ->', err);
      });
    }
  }]);
  return StorageRef;
}(_base.ReferenceBase);

var Storage = exports.Storage = function (_Base) {
  babelHelpers.inherits(Storage, _Base);

  function Storage(firestack) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    babelHelpers.classCallCheck(this, Storage);

    var _this3 = babelHelpers.possibleConstructorReturn(this, (Storage.__proto__ || Object.getPrototypeOf(Storage)).call(this, firestack, options));

    if (_this3.options.storageBucket) {
      _this3.setStorageUrl(_this3.options.storageBucket);
    }

    _this3.refs = {};
    return _this3;
  }

  babelHelpers.createClass(Storage, [{
    key: 'ref',
    value: function ref() {
      for (var _len = arguments.length, path = Array(_len), _key = 0; _key < _len; _key++) {
        path[_key] = arguments[_key];
      }

      var key = this._pathKey(path);
      if (!this.refs[key]) {
        var ref = new StorageRef(this, path);
        this.refs[key] = ref;
      }
      return this.refs[key];
    }
  }, {
    key: 'uploadFile',
    value: function uploadFile(name, filepath) {
      var _this4 = this;

      var metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var cb = arguments[3];

      var callback = cb;
      if (!callback || typeof callback !== 'function') {
        callback = function callback(evt) {};
      }

      filepath = filepath.replace("file://", "");

      var listeners = [];
      listeners.push(this._addListener('upload_progress', callback));
      listeners.push(this._addListener('upload_paused', callback));
      listeners.push(this._addListener('upload_resumed', callback));
      return (0, _promisify2.default)('uploadFile', FirestackStorage)(this.storageUrl, name, filepath, metadata).then(function (res) {
        listeners.forEach(_this4._removeListener);
        return res;
      });
    }
  }, {
    key: 'getRealPathFromURI',
    value: function getRealPathFromURI(uri) {
      return (0, _promisify2.default)('getRealPathFromURI', FirestackStorage)(uri);
    }
  }, {
    key: '_addListener',
    value: function _addListener(evt, cb) {
      return FirestackStorageEvt.addListener(evt, cb);
    }
  }, {
    key: '_removeListener',
    value: function _removeListener(evt) {
      return FirestackStorageEvt.removeListener(evt);
    }
  }, {
    key: 'setStorageUrl',
    value: function setStorageUrl(url) {
      this.storageUrl = 'gs://' + url;
    }
  }, {
    key: '_pathKey',
    value: function _pathKey() {
      for (var _len2 = arguments.length, path = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        path[_key2] = arguments[_key2];
      }

      return path.join('-');
    }
  }, {
    key: 'namespace',
    get: function get() {
      return 'firestack:storage';
    }
  }]);
  return Storage;
}(_base.Base);

Storage.constants = {
  'MAIN_BUNDLE_PATH': FirestackStorage.MAIN_BUNDLE_PATH,
  'CACHES_DIRECTORY_PATH': FirestackStorage.CACHES_DIRECTORY_PATH,
  'DOCUMENT_DIRECTORY_PATH': FirestackStorage.DOCUMENT_DIRECTORY_PATH,
  'EXTERNAL_DIRECTORY_PATH': FirestackStorage.EXTERNAL_DIRECTORY_PATH,
  'EXTERNAL_STORAGE_DIRECTORY_PATH': FirestackStorage.EXTERNAL_STORAGE_DIRECTORY_PATH,
  'TEMP_DIRECTORY_PATH': FirestackStorage.TEMP_DIRECTORY_PATH,
  'LIBRARY_DIRECTORY_PATH': FirestackStorage.LIBRARY_DIRECTORY_PATH,
  'FILETYPE_REGULAR': FirestackStorage.FILETYPE_REGULAR,
  'FILETYPE_DIRECTORY': FirestackStorage.FILETYPE_DIRECTORY
};
exports.default = Storage;