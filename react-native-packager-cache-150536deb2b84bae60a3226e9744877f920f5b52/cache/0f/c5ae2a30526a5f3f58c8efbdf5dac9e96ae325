"use strict";

var _reactNative = require("react-native");

var AppState = _reactNative.NativeModules.AppState;
var tag = "BackgroundJob:";
var jobModule = _reactNative.Platform.select({
  ios: {},
  android: _reactNative.NativeModules.BackgroundJob
});
var nativeJobs = _reactNative.Platform.select({
  ios: { jobs: {} },
  android: jobModule.jobs
});
var jobs = {};
var globalWarning = __DEV__;

var BackgroundJob = {
  NETWORK_TYPE_UNMETERED: jobModule.UNMETERED,
  NETWORK_TYPE_NONE: jobModule.NONE,
  NETWORK_TYPE_ANY: jobModule.ANY,

  register: function register(_ref) {
    var _this = this;

    var jobKey = _ref.jobKey,
        job = _ref.job;

    var existingJob = jobs[jobKey];

    if (!existingJob || !existingJob.registered) {
      var fn = function fn() {
        return regeneratorRuntime.async(function fn$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                job();

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, null, _this);
      };

      _reactNative.AppRegistry.registerHeadlessTask(jobKey, function () {
        return fn;
      });
      _reactNative.DeviceEventEmitter.addListener("RNBackgroundJob", job);

      if (existingJob) {
        jobs[jobKey].registered = true;
      } else {
        var scheduledJob = nativeJobs.filter(function (nJob) {
          return nJob.jobKey == jobKey;
        });
        var scheduled = scheduledJob[0] != undefined;
        jobs[jobKey] = { registered: true, scheduled: scheduled, job: job };
      }
    }
  },

  schedule: function schedule(_ref2) {
    var jobKey = _ref2.jobKey,
        timeout = _ref2.timeout,
        _ref2$period = _ref2.period,
        period = _ref2$period === undefined ? 900000 : _ref2$period,
        _ref2$persist = _ref2.persist,
        persist = _ref2$persist === undefined ? true : _ref2$persist,
        _ref2$warn = _ref2.warn,
        warn = _ref2$warn === undefined ? true : _ref2$warn,
        _ref2$networkType = _ref2.networkType,
        networkType = _ref2$networkType === undefined ? this.NETWORK_TYPE_NONE : _ref2$networkType,
        _ref2$requiresChargin = _ref2.requiresCharging,
        requiresCharging = _ref2$requiresChargin === undefined ? false : _ref2$requiresChargin,
        _ref2$requiresDeviceI = _ref2.requiresDeviceIdle,
        requiresDeviceIdle = _ref2$requiresDeviceI === undefined ? false : _ref2$requiresDeviceI,
        _ref2$alwaysRunning = _ref2.alwaysRunning,
        alwaysRunning = _ref2$alwaysRunning === undefined ? false : _ref2$alwaysRunning,
        notificationTitle = _ref2.notificationTitle,
        notificationText = _ref2.notificationText,
        notificationIcon = _ref2.notificationIcon;

    var savedJob = jobs[jobKey];

    if (!savedJob) {
      console.error(tag + " The job " + jobKey + " has not been registered, you must register it before you can schedule it.");
    } else {
      if (savedJob.scheduled && warn && globalWarning) {
        console.warn(tag + " Overwriting background job: " + jobKey);
      } else {
        jobs[jobKey].scheduled = true;
      }
      jobModule.schedule(jobKey, timeout, period, persist, networkType, requiresCharging, requiresDeviceIdle, alwaysRunning, notificationTitle, notificationIcon, notificationText);
    }
  },

  getAll: function getAll(_ref3) {
    var callback = _ref3.callback;

    jobModule.getAll(callback);
  },

  cancel: function cancel(_ref4) {
    var jobKey = _ref4.jobKey,
        _ref4$warn = _ref4.warn,
        warn = _ref4$warn === undefined ? true : _ref4$warn;

    if (warn && globalWarning && (!jobs[jobKey] || !jobs[jobKey].scheduled)) {
      console.warn(tag + " Trying to cancel the job " + jobKey + " but it is not scheduled");
    }
    jobModule.cancel(jobKey);
    jobs[jobKey] ? jobs[jobKey].scheduled = false : null;
  },

  cancelAll: function cancelAll() {
    jobModule.cancelAll();
    var keys = Object.keys(jobs);
    keys.map(function (key) {
      jobs[key].scheduled = false;
    });
  },

  setGlobalWarnings: function setGlobalWarnings(warn) {
    globalWarning = warn;
  }
};
if (_reactNative.Platform.OS == "ios") {
  Object.keys(BackgroundJob).map(function (v) {
    BackgroundJob[v] = function () {
      if (globalWarning) {
        console.warn("react-native-background-job is not available on iOS yet. See https://github.com/vikeri/react-native-background-job#supported-platforms");
      }
    };
  });
}
module.exports = BackgroundJob;