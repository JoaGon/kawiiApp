'use strict';

var reduxSaga_utils = require('redux-saga/utils');
var ramdasauce = require('ramdasauce');
var ramda = require('ramda');

var TAKE = 'TAKE';
var PUT = 'PUT';
var CALL = 'CALL';
var CPS = 'CPS';
var FORK = 'FORK';
var JOIN = 'JOIN';
var RACE = 'RACE';
var CANCEL = 'CANCEL';
var SELECT = 'SELECT';
var PARALLEL = 'PARALLEL';
var ITERATOR = 'ITERATOR';
var PROMISE = 'PROMISE';
var UNKNOWN = 'UNKNOWN';
var PENDING = 'PENDING';
var RESOLVED = 'RESOLVED';
var REJECTED = 'REJECTED';
var CANCELLED = 'CANCELLED';

var getEffectName = function getEffectName(effect) {
  if (!effect) return UNKNOWN;
  if (effect instanceof Promise) return PROMISE;
  if (reduxSaga_utils.asEffect.take(effect)) return TAKE;
  if (reduxSaga_utils.asEffect.put(effect)) return PUT;
  if (reduxSaga_utils.asEffect.call(effect)) return CALL;
  if (reduxSaga_utils.asEffect.cps(effect)) return CPS;
  if (reduxSaga_utils.asEffect.fork(effect)) return FORK;
  if (reduxSaga_utils.asEffect.join(effect)) return JOIN;
  if (reduxSaga_utils.asEffect.race(effect)) return RACE;
  if (reduxSaga_utils.asEffect.cancel(effect)) return CANCEL;
  if (reduxSaga_utils.asEffect.select(effect)) return SELECT;
  if (reduxSaga_utils.is.array(effect)) return PARALLEL;
  if (reduxSaga_utils.is.iterator(effect)) return ITERATOR;
  return UNKNOWN;
};

var getEffectDescription = function getEffectDescription(effect) {
  if (!effect) return UNKNOWN;
  if (effect instanceof Promise) {
    var display = void 0;
    if (effect.name) {
      display = PROMISE + '(' + effect.name + ')';
    } else if (effect.constructor instanceof Promise.constructor) {
      display = PROMISE;
    } else {
      display = PROMISE + '(' + effect.constructor.name + ')';
    }
    return display;
  }
  if (effect.root) return effect.saga.name;
  var data = void 0;
  if (data = reduxSaga_utils.asEffect.take(effect)) return data.pattern || 'channel';
  if (data = reduxSaga_utils.asEffect.put(effect)) return data.channel ? data.action : data.action.type;
  if (data = reduxSaga_utils.asEffect.call(effect)) return ramdasauce.isNilOrEmpty(data.fn.name) ? '(anonymous)' : data.fn.name;
  if (data = reduxSaga_utils.asEffect.cps(effect)) return data.fn.name;
  if (data = reduxSaga_utils.asEffect.fork(effect)) return data.fn.name;
  if (data = reduxSaga_utils.asEffect.join(effect)) return data.name;
  if (reduxSaga_utils.asEffect.race(effect)) return null;
  if (data = reduxSaga_utils.asEffect.cancel(effect)) return data.name;
  if (data = reduxSaga_utils.asEffect.select(effect)) return data.selector.name;
  if (reduxSaga_utils.is.array(effect)) return null;
  if (reduxSaga_utils.is.iterator(effect)) return effect.name;
  return UNKNOWN;
};

var _createSagaMonitor = function _createSagaMonitor(reactotron, options) {
  var effects = {};

  var byParentId = ramda.propEq('parentEffectId', ramda.__);
  var byLabel = ramda.propEq('label', ramda.__);
  var getChildEffectInfos = function getChildEffectInfos(parentEffectId) {
    return ramda.filter(byParentId(parentEffectId), ramda.values(effects));
  };
  var getChildEffectIds = function getChildEffectIds(effectId) {
    return ramda.pluck('effectId', getChildEffectInfos(effectId));
  };

  var timer = reactotron.startTimer();

  var effectTriggered = function effectTriggered(description) {
    var effect = description.effect,
        effectId = description.effectId,
        parentEffectId = description.parentEffectId,
        label = description.label;

    var effectInfo = {
      effectId: effectId,
      parentEffectId: parentEffectId,
      effect: effect,
      label: label,
      status: PENDING,
      name: getEffectName(effect),
      description: getEffectDescription(effect),
      result: null,
      startedAt: timer()
    };

    effects[effectId] = effectInfo;
  };

  var updateDuration = function updateDuration(effectInfo) {
    effectInfo.duration = timer() - effectInfo.startedAt;
  };

  var taskResolved = function taskResolved(effectId, taskResult) {
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    var duration = effectInfo.duration;

    var parentEffectId = effectInfo.parentEffectId;

    var parentEffectInfo = effects[parentEffectId];
    var children = [];

    var sagaDescription = void 0;

    var triggerType = void 0;

    if (effectInfo.name === FORK) {
      var args = ramda.pathOr([], ramda.split('.', 'effect.FORK.args'), effectInfo);
      var lastArg = ramda.last(args);
      triggerType = lastArg && lastArg.type;
      if (parentEffectInfo) {
        if (parentEffectInfo.name === ITERATOR) {
          sagaDescription = parentEffectInfo.description;
        }
      } else {
        sagaDescription = '(root)';
        triggerType = effectInfo.description + '()';
      }

      var buildChild = function buildChild(depth, effectId) {
        var sourceEffectInfo = effects[effectId];
        if (ramda.isNil(sourceEffectInfo)) return;

        var extra = null;
        switch (sourceEffectInfo.name) {
          case CALL:
            extra = sourceEffectInfo.effect[sourceEffectInfo.name].args;
            break;

          case PUT:
            extra = sourceEffectInfo.effect[sourceEffectInfo.name].action;
            break;

          case RACE:
            break;

          default:
            extra = sourceEffectInfo.effect[sourceEffectInfo.name];
            break;
        }

        children.push({
          depth: depth,
          effectId: sourceEffectInfo.effectId,
          parentEffectId: sourceEffectInfo.parentEffectId || null,
          name: sourceEffectInfo.name || null,
          description: sourceEffectInfo.description || null,
          duration: Math.round(sourceEffectInfo.duration),
          status: sourceEffectInfo.status || null,
          winner: sourceEffectInfo.winner || null,
          loser: sourceEffectInfo.loser || null,
          result: sourceEffectInfo.result || null,
          extra: extra || null
        });

        ramda.forEach(function (x) {
          return buildChild(depth + 1, x);
        }, getChildEffectIds(effectId));
      };
      var xs = getChildEffectIds(effectId);
      ramda.forEach(function (effectId) {
        return buildChild(0, effectId);
      }, xs);
    }

    reactotron.send('saga.task.complete', {
      triggerType: triggerType || effectInfo.description,
      description: sagaDescription,
      duration: Math.round(duration),
      children: children
    });
  };

  var effectResolved = function effectResolved(effectId, result) {
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    effectInfo.result = result;

    if (reduxSaga_utils.is.task(result)) {
      var onTaskResult = function onTaskResult(taskResult) {
        if (result.isCancelled()) {
          effectCancelled(effectId);
        } else {
          effectResolved(effectId, taskResult);
          taskResolved(effectId, taskResult);
        }
      };

      result.done.then(onTaskResult, function (error) {
        effectRejected(effectId, error);
        if (!error.reactotronWasHere) {
          reactotron.reportError(error);
        }
        error.reactotronWasHere = true;
      });
    } else {
      effectInfo.status = RESOLVED;
      effectInfo.result = result;
      if (effectInfo.name === RACE) {
        setRaceWinner(effectId, result);
      }
    }
  };

  var setRaceWinner = function setRaceWinner(effectId, resultOrError) {
    var winnerLabel = Object.keys(resultOrError)[0];
    var children = getChildEffectInfos(effectId);
    var winningChildren = ramda.filter(byLabel(winnerLabel), children);
    var losingChildren = ramda.reject(byLabel(winnerLabel), children);
    var setWinner = function setWinner(effectInfo) {
      effectInfo.winner = true;
    };
    var setLoser = function setLoser(effectInfo) {
      effectInfo.loser = true;
    };

    ramda.forEach(setWinner, winningChildren);
    ramda.forEach(setLoser, losingChildren);
  };

  var effectRejected = function effectRejected(effectId, error) {
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    effectInfo.status = REJECTED;
    effectInfo.error = error;
    if (effectInfo.name === RACE) {
      setRaceWinner(effectId, error);
    }
  };

  var effectCancelled = function effectCancelled(effectId) {
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    effectInfo.status = CANCELLED;
  };

  return {
    effectTriggered: effectTriggered,
    effectResolved: effectResolved,
    effectRejected: effectRejected,
    effectCancelled: effectCancelled,
    actionDispatched: function actionDispatched() {}
  };
};

var plugin$1 = function plugin$1(pluginConfig) {
  return function (reactotron) {
    return {
      features: {
        createSagaMonitor: function createSagaMonitor(options) {
          return _createSagaMonitor(reactotron, options);
        }
      }
    };
  };
};

module.exports = plugin$1;