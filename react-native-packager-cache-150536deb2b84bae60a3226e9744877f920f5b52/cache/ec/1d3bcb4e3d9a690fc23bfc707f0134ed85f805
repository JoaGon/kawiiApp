(function () {
  "use strict";

  function immutableInit(config) {
    var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && (typeof Symbol === 'function' ? Symbol.for : '@@for') && (typeof Symbol === 'function' ? Symbol.for : '@@for')('react.element');
    var REACT_ELEMENT_TYPE_FALLBACK = 0xeac7;

    var globalConfig = {
      use_static: false
    };
    if (isObject(config)) {
      if (config.use_static !== undefined) {
        globalConfig.use_static = Boolean(config.use_static);
      }
    }

    function isObject(data) {
      return typeof data === 'object' && !Array.isArray(data) && data !== null;
    }

    function instantiateEmptyObject(obj) {
      var prototype = Object.getPrototypeOf(obj);
      if (!prototype) {
        return {};
      } else {
        return Object.create(prototype);
      }
    }

    function addPropertyTo(target, methodName, value) {
      Object.defineProperty(target, methodName, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: value
      });
    }

    function banProperty(target, methodName) {
      addPropertyTo(target, methodName, function () {
        throw new ImmutableError("The " + methodName + " method cannot be invoked on an Immutable data structure.");
      });
    }

    var immutabilityTag = "__immutable_invariants_hold";

    function addImmutabilityTag(target) {
      addPropertyTo(target, immutabilityTag, true);
    }

    function isImmutable(target) {
      if (typeof target === "object") {
        return target === null || Boolean(Object.getOwnPropertyDescriptor(target, immutabilityTag));
      } else {
        return true;
      }
    }

    function isEqual(a, b) {
      return a === b || a !== a && b !== b;
    }

    function isMergableObject(target) {
      return target !== null && typeof target === "object" && !Array.isArray(target) && !(target instanceof Date);
    }

    var mutatingObjectMethods = ["setPrototypeOf"];

    var nonMutatingObjectMethods = ["keys"];

    var mutatingArrayMethods = mutatingObjectMethods.concat(["push", "pop", "sort", "splice", "shift", "unshift", "reverse"]);

    var nonMutatingArrayMethods = nonMutatingObjectMethods.concat(["map", "filter", "slice", "concat", "reduce", "reduceRight"]);

    var mutatingDateMethods = mutatingObjectMethods.concat(["setDate", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setSeconds", "setTime", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setYear"]);

    function ImmutableError(message) {
      this.name = 'MyError';
      this.message = message;
      this.stack = new Error().stack;
    }
    ImmutableError.prototype = new Error();
    ImmutableError.prototype.constructor = Error;

    function makeImmutable(obj, bannedMethods) {
      addImmutabilityTag(obj);

      if (process.env.NODE_ENV !== "production") {
        for (var index in bannedMethods) {
          if (bannedMethods.hasOwnProperty(index)) {
            banProperty(obj, bannedMethods[index]);
          }
        }

        Object.freeze(obj);
      }

      return obj;
    }

    function makeMethodReturnImmutable(obj, methodName) {
      var currentMethod = obj[methodName];

      addPropertyTo(obj, methodName, function () {
        return Immutable(currentMethod.apply(obj, arguments));
      });
    }

    function arraySet(idx, value, config) {
      var deep = config && config.deep;

      if (idx in this) {
        if (deep && this[idx] !== value && isMergableObject(value) && isMergableObject(this[idx])) {
          value = Immutable.merge(this[idx], value, { deep: true, mode: 'replace' });
        }
        if (isEqual(this[idx], value)) {
          return this;
        }
      }

      var mutable = asMutableArray.call(this);
      mutable[idx] = Immutable(value);
      return makeImmutableArray(mutable);
    }

    var immutableEmptyArray = Immutable([]);

    function arraySetIn(pth, value, config) {
      var head = pth[0];

      if (pth.length === 1) {
        return arraySet.call(this, head, value, config);
      } else {
        var tail = pth.slice(1);
        var thisHead = this[head];
        var newValue;

        if (typeof thisHead === "object" && thisHead !== null) {
          newValue = Immutable.setIn(thisHead, tail, value);
        } else {
          var nextHead = tail[0];

          if (nextHead !== '' && isFinite(nextHead)) {
            newValue = arraySetIn.call(immutableEmptyArray, tail, value);
          } else {
            newValue = objectSetIn.call(immutableEmptyObject, tail, value);
          }
        }

        if (head in this && thisHead === newValue) {
          return this;
        }

        var mutable = asMutableArray.call(this);
        mutable[head] = newValue;
        return makeImmutableArray(mutable);
      }
    }

    function makeImmutableArray(array) {
      for (var index in nonMutatingArrayMethods) {
        if (nonMutatingArrayMethods.hasOwnProperty(index)) {
          var methodName = nonMutatingArrayMethods[index];
          makeMethodReturnImmutable(array, methodName);
        }
      }

      if (!globalConfig.use_static) {
        addPropertyTo(array, "flatMap", flatMap);
        addPropertyTo(array, "asObject", asObject);
        addPropertyTo(array, "asMutable", asMutableArray);
        addPropertyTo(array, "set", arraySet);
        addPropertyTo(array, "setIn", arraySetIn);
        addPropertyTo(array, "update", update);
        addPropertyTo(array, "updateIn", updateIn);
        addPropertyTo(array, "getIn", getIn);
      }

      for (var i = 0, length = array.length; i < length; i++) {
        array[i] = Immutable(array[i]);
      }

      return makeImmutable(array, mutatingArrayMethods);
    }

    function makeImmutableDate(date) {
      if (!globalConfig.use_static) {
        addPropertyTo(date, "asMutable", asMutableDate);
      }

      return makeImmutable(date, mutatingDateMethods);
    }

    function asMutableDate() {
      return new Date(this.getTime());
    }

    function flatMap(iterator) {
      if (arguments.length === 0) {
        return this;
      }

      var result = [],
          length = this.length,
          index;

      for (index = 0; index < length; index++) {
        var iteratorResult = iterator(this[index], index, this);

        if (Array.isArray(iteratorResult)) {
          result.push.apply(result, iteratorResult);
        } else {
          result.push(iteratorResult);
        }
      }

      return makeImmutableArray(result);
    }

    function without(remove) {
      if (typeof remove === "undefined" && arguments.length === 0) {
        return this;
      }

      if (typeof remove !== "function") {
        var keysToRemoveArray = Array.isArray(remove) ? remove.slice() : Array.prototype.slice.call(arguments);

        keysToRemoveArray.forEach(function (el, idx, arr) {
          if (typeof el === "number") {
            arr[idx] = el.toString();
          }
        });

        remove = function remove(val, key) {
          return keysToRemoveArray.indexOf(key) !== -1;
        };
      }

      var result = instantiateEmptyObject(this);

      for (var key in this) {
        if (this.hasOwnProperty(key) && remove(this[key], key) === false) {
          result[key] = this[key];
        }
      }

      return makeImmutableObject(result);
    }

    function asMutableArray(opts) {
      var result = [],
          i,
          length;

      if (opts && opts.deep) {
        for (i = 0, length = this.length; i < length; i++) {
          result.push(asDeepMutable(this[i]));
        }
      } else {
        for (i = 0, length = this.length; i < length; i++) {
          result.push(this[i]);
        }
      }

      return result;
    }

    function asObject(iterator) {
      if (typeof iterator !== "function") {
        iterator = function iterator(value) {
          return value;
        };
      }

      var result = {},
          length = this.length,
          index;

      for (index = 0; index < length; index++) {
        var pair = iterator(this[index], index, this),
            key = pair[0],
            value = pair[1];

        result[key] = value;
      }

      return makeImmutableObject(result);
    }

    function asDeepMutable(obj) {
      if (!obj || typeof obj !== 'object' || !Object.getOwnPropertyDescriptor(obj, immutabilityTag) || obj instanceof Date) {
        return obj;
      }
      return Immutable.asMutable(obj, { deep: true });
    }

    function quickCopy(src, dest) {
      for (var key in src) {
        if (Object.getOwnPropertyDescriptor(src, key)) {
          dest[key] = src[key];
        }
      }

      return dest;
    }

    function merge(other, config) {
      if (arguments.length === 0) {
        return this;
      }

      if (other === null || typeof other !== "object") {
        throw new TypeError("Immutable#merge can only be invoked with objects or arrays, not " + JSON.stringify(other));
      }

      var receivedArray = Array.isArray(other),
          deep = config && config.deep,
          mode = config && config.mode || 'merge',
          merger = config && config.merger,
          result;

      function addToResult(currentObj, otherObj, key) {
        var immutableValue = Immutable(otherObj[key]);
        var mergerResult = merger && merger(currentObj[key], immutableValue, config);
        var currentValue = currentObj[key];

        if (result !== undefined || mergerResult !== undefined || !currentObj.hasOwnProperty(key) || !isEqual(immutableValue, currentValue)) {

          var newValue;

          if (mergerResult) {
            newValue = mergerResult;
          } else if (deep && isMergableObject(currentValue) && isMergableObject(immutableValue)) {
            newValue = Immutable.merge(currentValue, immutableValue, config);
          } else {
            newValue = immutableValue;
          }

          if (!isEqual(currentValue, newValue) || !currentObj.hasOwnProperty(key)) {
            if (result === undefined) {
              result = quickCopy(currentObj, instantiateEmptyObject(currentObj));
            }

            result[key] = newValue;
          }
        }
      }

      function clearDroppedKeys(currentObj, otherObj) {
        for (var key in currentObj) {
          if (!otherObj.hasOwnProperty(key)) {
            if (result === undefined) {
              result = quickCopy(currentObj, instantiateEmptyObject(currentObj));
            }
            delete result[key];
          }
        }
      }

      var key;

      if (!receivedArray) {
        for (key in other) {
          if (Object.getOwnPropertyDescriptor(other, key)) {
            addToResult(this, other, key);
          }
        }
        if (mode === 'replace') {
          clearDroppedKeys(this, other);
        }
      } else {
        for (var index = 0, length = other.length; index < length; index++) {
          var otherFromArray = other[index];

          for (key in otherFromArray) {
            if (otherFromArray.hasOwnProperty(key)) {
              addToResult(result !== undefined ? result : this, otherFromArray, key);
            }
          }
        }
      }

      if (result === undefined) {
        return this;
      } else {
        return makeImmutableObject(result);
      }
    }

    function objectReplace(value, config) {
      var deep = config && config.deep;

      if (arguments.length === 0) {
        return this;
      }

      if (value === null || typeof value !== "object") {
        throw new TypeError("Immutable#replace can only be invoked with objects or arrays, not " + JSON.stringify(value));
      }

      return Immutable.merge(this, value, { deep: deep, mode: 'replace' });
    }

    var immutableEmptyObject = Immutable({});

    function objectSetIn(path, value, config) {
      if (!(path instanceof Array) || path.length === 0) {
        throw new TypeError("The first argument to Immutable#setIn must be an array containing at least one \"key\" string.");
      }

      var head = path[0];
      if (path.length === 1) {
        return objectSet.call(this, head, value, config);
      }

      var tail = path.slice(1);
      var newValue;
      var thisHead = this[head];

      if (this.hasOwnProperty(head) && typeof thisHead === "object" && thisHead !== null) {
        newValue = Immutable.setIn(thisHead, tail, value);
      } else {
        newValue = objectSetIn.call(immutableEmptyObject, tail, value);
      }

      if (this.hasOwnProperty(head) && thisHead === newValue) {
        return this;
      }

      var mutable = quickCopy(this, instantiateEmptyObject(this));
      mutable[head] = newValue;
      return makeImmutableObject(mutable);
    }

    function objectSet(property, value, config) {
      var deep = config && config.deep;

      if (this.hasOwnProperty(property)) {
        if (deep && this[property] !== value && isMergableObject(value) && isMergableObject(this[property])) {
          value = Immutable.merge(this[property], value, { deep: true, mode: 'replace' });
        }
        if (isEqual(this[property], value)) {
          return this;
        }
      }

      var mutable = quickCopy(this, instantiateEmptyObject(this));
      mutable[property] = Immutable(value);
      return makeImmutableObject(mutable);
    }

    function update(property, updater) {
      var restArgs = Array.prototype.slice.call(arguments, 2);
      var initialVal = this[property];
      return Immutable.set(this, property, updater.apply(initialVal, [initialVal].concat(restArgs)));
    }

    function getInPath(obj, path) {
      for (var i = 0, l = path.length; obj != null && i < l; i++) {
        obj = obj[path[i]];
      }

      return i && i == l ? obj : undefined;
    }

    function updateIn(path, updater) {
      var restArgs = Array.prototype.slice.call(arguments, 2);
      var initialVal = getInPath(this, path);

      return Immutable.setIn(this, path, updater.apply(initialVal, [initialVal].concat(restArgs)));
    }

    function getIn(path, defaultValue) {
      var value = getInPath(this, path);
      return value === undefined ? defaultValue : value;
    }

    function asMutableObject(opts) {
      var result = instantiateEmptyObject(this),
          key;

      if (opts && opts.deep) {
        for (key in this) {
          if (this.hasOwnProperty(key)) {
            result[key] = asDeepMutable(this[key]);
          }
        }
      } else {
        for (key in this) {
          if (this.hasOwnProperty(key)) {
            result[key] = this[key];
          }
        }
      }

      return result;
    }

    function instantiatePlainObject() {
      return {};
    }

    function makeImmutableObject(obj) {
      if (!globalConfig.use_static) {
        addPropertyTo(obj, "merge", merge);
        addPropertyTo(obj, "replace", objectReplace);
        addPropertyTo(obj, "without", without);
        addPropertyTo(obj, "asMutable", asMutableObject);
        addPropertyTo(obj, "set", objectSet);
        addPropertyTo(obj, "setIn", objectSetIn);
        addPropertyTo(obj, "update", update);
        addPropertyTo(obj, "updateIn", updateIn);
        addPropertyTo(obj, "getIn", getIn);
      }

      return makeImmutable(obj, mutatingObjectMethods);
    }

    function isReactElement(obj) {
      return typeof obj === 'object' && obj !== null && (obj.$$typeof === REACT_ELEMENT_TYPE_FALLBACK || obj.$$typeof === REACT_ELEMENT_TYPE);
    }

    function isFileObject(obj) {
      return typeof File !== 'undefined' && obj instanceof File;
    }

    function isPromise(obj) {
      return typeof obj === 'object' && typeof obj.then === 'function';
    }

    function isError(obj) {
      return obj instanceof Error;
    }

    function Immutable(obj, options, stackRemaining) {
      if (isImmutable(obj) || isReactElement(obj) || isFileObject(obj) || isError(obj)) {
        return obj;
      } else if (isPromise(obj)) {
        return obj.then(Immutable);
      } else if (Array.isArray(obj)) {
        return makeImmutableArray(obj.slice());
      } else if (obj instanceof Date) {
        return makeImmutableDate(new Date(obj.getTime()));
      } else {
        var prototype = options && options.prototype;
        var instantiateEmptyObject = !prototype || prototype === Object.prototype ? instantiatePlainObject : function () {
          return Object.create(prototype);
        };
        var clone = instantiateEmptyObject();

        if (process.env.NODE_ENV !== "production") {
          if (stackRemaining == null) {
            stackRemaining = 64;
          }
          if (stackRemaining <= 0) {
            throw new ImmutableError("Attempt to construct Immutable from a deeply nested object was detected." + " Have you tried to wrap an object with circular references (e.g. React element)?" + " See https://github.com/rtfeldman/seamless-immutable/wiki/Deeply-nested-object-was-detected for details.");
          }
          stackRemaining -= 1;
        }

        for (var key in obj) {
          if (Object.getOwnPropertyDescriptor(obj, key)) {
            clone[key] = Immutable(obj[key], undefined, stackRemaining);
          }
        }

        return makeImmutableObject(clone);
      }
    }

    function toStatic(fn) {
      function staticWrapper() {
        var args = [].slice.call(arguments);
        var self = args.shift();
        return fn.apply(self, args);
      }

      return staticWrapper;
    }

    function toStaticObjectOrArray(fnObject, fnArray) {
      function staticWrapper() {
        var args = [].slice.call(arguments);
        var self = args.shift();
        if (Array.isArray(self)) {
          return fnArray.apply(self, args);
        } else {
          return fnObject.apply(self, args);
        }
      }

      return staticWrapper;
    }

    function toStaticObjectOrDateOrArray(fnObject, fnArray, fnDate) {
      function staticWrapper() {
        var args = [].slice.call(arguments);
        var self = args.shift();
        if (Array.isArray(self)) {
          return fnArray.apply(self, args);
        } else if (self instanceof Date) {
          return fnDate.apply(self, args);
        } else {
          return fnObject.apply(self, args);
        }
      }

      return staticWrapper;
    }

    Immutable.from = Immutable;
    Immutable.isImmutable = isImmutable;
    Immutable.ImmutableError = ImmutableError;
    Immutable.merge = toStatic(merge);
    Immutable.replace = toStatic(objectReplace);
    Immutable.without = toStatic(without);
    Immutable.asMutable = toStaticObjectOrDateOrArray(asMutableObject, asMutableArray, asMutableDate);
    Immutable.set = toStaticObjectOrArray(objectSet, arraySet);
    Immutable.setIn = toStaticObjectOrArray(objectSetIn, arraySetIn);
    Immutable.update = toStatic(update);
    Immutable.updateIn = toStatic(updateIn);
    Immutable.getIn = toStatic(getIn);
    Immutable.flatMap = toStatic(flatMap);
    Immutable.asObject = toStatic(asObject);
    if (!globalConfig.use_static) {
      Immutable.static = immutableInit({
        use_static: true
      });
    }

    Object.freeze(Immutable);

    return Immutable;
  }

  var Immutable = immutableInit();

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return Immutable;
    });
  } else if (typeof module === "object") {
    module.exports = Immutable;
  } else if (typeof exports === "object") {
    exports.Immutable = Immutable;
  } else if (typeof window === "object") {
    window.Immutable = Immutable;
  } else if (typeof global === "object") {
    global.Immutable = Immutable;
  }
})();